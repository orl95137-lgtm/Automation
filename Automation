--------------------------------------------------------------------
-- CORE SERVICES
--------------------------------------------------------------------
local Players = game:GetService("Players")
local lp = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local placeId = game.PlaceId

--------------------------------------------------------------------
-- SAFE WRAPPERS (executor functions may not always exist)
--------------------------------------------------------------------
local function safeFireProximityPrompt(prompt)
    local ok, err = pcall(function()
        fireproximityprompt(prompt)
    end)
    if not ok then warn("[AUTO] fireproximityprompt failed: " .. tostring(err)) end
    return ok
end

local function safeFireClickDetector(cd)
    local ok, err = pcall(function()
        fireclickdetector(cd)
    end)
    if not ok then warn("[AUTO] fireclickdetector failed: " .. tostring(err)) end
    return ok
end

local function safeSetCFrame(part, cf)
    local ok, err = pcall(function()
        part.CFrame = cf
    end)
    if not ok then warn("[AUTO] CFrame set failed: " .. tostring(err)) end
    return ok
end

--------------------------------------------------------------------
-- WEBHOOK PERSISTENCE
--------------------------------------------------------------------
local WEBHOOK_FILE = "webhook.txt"
local WEBHOOK = ""

pcall(function()
    if isfile(WEBHOOK_FILE) then
        local saved = readfile(WEBHOOK_FILE)
        if saved and saved ~= "" then
            WEBHOOK = saved
        end
    end
end)

local function saveWebhook(url)
    pcall(function()
        writefile(WEBHOOK_FILE, url)
    end)
end

--------------------------------------------------------------------
-- GEM TRACKING  (GemsLabel declared later; task.spawn defers safely)
--------------------------------------------------------------------
local currentGems = "N/A"
local GemsLabel  -- forward declaration; assigned after UI creation

local function initGemTracker()
    local data = lp:WaitForChild("Data", 10)
    if not data then return end
    local gems = data:WaitForChild("Gems", 10)
    if not gems then return end

    currentGems = gems.Value

    gems:GetPropertyChangedSignal("Value"):Connect(function()
        currentGems = gems.Value
        if GemsLabel then
            GemsLabel.Text = "ðŸ’Ž Gems: " .. tostring(currentGems)
        end
    end)
end

--------------------------------------------------------------------
-- STYLED UI
--------------------------------------------------------------------
local PlayerGui = lp:WaitForChild("PlayerGui")

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "AutoWebhookUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.Parent = PlayerGui

local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, 360, 0, 230)
MainFrame.Position = UDim2.new(0.5, -180, 0.5, -115)
MainFrame.BackgroundColor3 = Color3.fromRGB(18, 18, 24)
MainFrame.BorderSizePixel = 0
MainFrame.Active = true
MainFrame.Draggable = true
MainFrame.Parent = ScreenGui

local Corner = Instance.new("UICorner")
Corner.CornerRadius = UDim.new(0, 10)
Corner.Parent = MainFrame

local Stroke = Instance.new("UIStroke")
Stroke.Color = Color3.fromRGB(90, 90, 200)
Stroke.Thickness = 1.5
Stroke.Parent = MainFrame

local TitleBar = Instance.new("Frame")
TitleBar.Size = UDim2.new(1, 0, 0, 40)
TitleBar.BackgroundColor3 = Color3.fromRGB(26, 26, 36)
TitleBar.BorderSizePixel = 0
TitleBar.Parent = MainFrame

local TitleBarCorner = Instance.new("UICorner")
TitleBarCorner.CornerRadius = UDim.new(0, 10)
TitleBarCorner.Parent = TitleBar

local TitleBarFix = Instance.new("Frame")
TitleBarFix.Size = UDim2.new(1, 0, 0.5, 0)
TitleBarFix.Position = UDim2.new(0, 0, 0.5, 0)
TitleBarFix.BackgroundColor3 = Color3.fromRGB(26, 26, 36)
TitleBarFix.BorderSizePixel = 0
TitleBarFix.Parent = TitleBar

local TitleLabel = Instance.new("TextLabel")
TitleLabel.Text = "ðŸ” Auto Webhook Sender"
TitleLabel.Size = UDim2.new(1, -50, 1, 0)
TitleLabel.Position = UDim2.new(0, 12, 0, 0)
TitleLabel.BackgroundTransparency = 1
TitleLabel.TextColor3 = Color3.fromRGB(220, 220, 255)
TitleLabel.TextSize = 15
TitleLabel.Font = Enum.Font.GothamBold
TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
TitleLabel.Parent = TitleBar

local CloseBtn = Instance.new("TextButton")
CloseBtn.Text = "âœ•"
CloseBtn.Size = UDim2.new(0, 30, 0, 30)
CloseBtn.Position = UDim2.new(1, -38, 0, 5)
CloseBtn.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
CloseBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseBtn.TextSize = 14
CloseBtn.Font = Enum.Font.GothamBold
CloseBtn.BorderSizePixel = 0
CloseBtn.Parent = TitleBar

local CloseCorner = Instance.new("UICorner")
CloseCorner.CornerRadius = UDim.new(0, 6)
CloseCorner.Parent = CloseBtn

local StatusLabel = Instance.new("TextLabel")
StatusLabel.Text = "âšª Status: Starting..."
StatusLabel.Size = UDim2.new(1, -20, 0, 20)
StatusLabel.Position = UDim2.new(0, 10, 0, 50)
StatusLabel.BackgroundTransparency = 1
StatusLabel.TextColor3 = Color3.fromRGB(170, 170, 200)
StatusLabel.TextSize = 13
StatusLabel.Font = Enum.Font.Gotham
StatusLabel.TextXAlignment = Enum.TextXAlignment.Left
StatusLabel.Parent = MainFrame

local CycleLabel = Instance.new("TextLabel")
CycleLabel.Text = "ðŸ” Current Loop: N/A"
CycleLabel.Size = UDim2.new(1, -20, 0, 20)
CycleLabel.Position = UDim2.new(0, 10, 0, 75)
CycleLabel.BackgroundTransparency = 1
CycleLabel.TextColor3 = Color3.fromRGB(170, 170, 200)
CycleLabel.TextSize = 13
CycleLabel.Font = Enum.Font.Gotham
CycleLabel.TextXAlignment = Enum.TextXAlignment.Left
CycleLabel.Parent = MainFrame

-- Assign forward-declared GemsLabel here so initGemTracker can use it
GemsLabel = Instance.new("TextLabel")
GemsLabel.Text = "ðŸ’Ž Gems: N/A"
GemsLabel.Size = UDim2.new(1, -20, 0, 20)
GemsLabel.Position = UDim2.new(0, 10, 0, 95)
GemsLabel.BackgroundTransparency = 1
GemsLabel.TextColor3 = Color3.fromRGB(170, 170, 200)
GemsLabel.TextSize = 13
GemsLabel.Font = Enum.Font.Gotham
GemsLabel.TextXAlignment = Enum.TextXAlignment.Left
GemsLabel.Parent = MainFrame

local WebhookBox = Instance.new("TextBox")
WebhookBox.PlaceholderText = "Paste webhook URL here..."
WebhookBox.Text = WEBHOOK
WebhookBox.Size = UDim2.new(1, -20, 0, 36)
WebhookBox.Position = UDim2.new(0, 10, 0, 128)
WebhookBox.BackgroundColor3 = Color3.fromRGB(30, 30, 42)
WebhookBox.TextColor3 = Color3.fromRGB(220, 220, 255)
WebhookBox.PlaceholderColor3 = Color3.fromRGB(100, 100, 130)
WebhookBox.TextSize = 12
WebhookBox.Font = Enum.Font.Gotham
WebhookBox.ClearTextOnFocus = false
WebhookBox.BorderSizePixel = 0
WebhookBox.Parent = MainFrame

local BoxCorner = Instance.new("UICorner")
BoxCorner.CornerRadius = UDim.new(0, 7)
BoxCorner.Parent = WebhookBox

local BoxStroke = Instance.new("UIStroke")
BoxStroke.Color = Color3.fromRGB(70, 70, 160)
BoxStroke.Thickness = 1
BoxStroke.Parent = WebhookBox

local SaveBtn = Instance.new("TextButton")
SaveBtn.Text = "ðŸ’¾  Save Webhook"
SaveBtn.Size = UDim2.new(1, -20, 0, 34)
SaveBtn.Position = UDim2.new(0, 10, 0, 176)
SaveBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 200)
SaveBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
SaveBtn.TextSize = 13
SaveBtn.Font = Enum.Font.GothamBold
SaveBtn.BorderSizePixel = 0
SaveBtn.Parent = MainFrame

local SaveCorner = Instance.new("UICorner")
SaveCorner.CornerRadius = UDim.new(0, 7)
SaveCorner.Parent = SaveBtn

--------------------------------------------------------------------
-- UI HELPERS
--------------------------------------------------------------------
local function setStatus(text, color)
    StatusLabel.Text = "â— Status: " .. text
    StatusLabel.TextColor3 = color or Color3.fromRGB(170, 170, 200)
end

local function setCycle(n)
    CycleLabel.Text = "ðŸ” Current Loop: " .. tostring(n)
end

SaveBtn.MouseButton1Click:Connect(function()
    local newUrl = WebhookBox.Text
    if newUrl == "" or not newUrl:match("^https://") then
        setStatus("Invalid URL!", Color3.fromRGB(220, 80, 80))
        return
    end
    WEBHOOK = newUrl
    saveWebhook(newUrl)
    SaveBtn.Text = "âœ”  Saved!"
    SaveBtn.BackgroundColor3 = Color3.fromRGB(60, 180, 100)
    setStatus("Webhook saved", Color3.fromRGB(80, 220, 120))
    task.wait(1.5)
    SaveBtn.Text = "ðŸ’¾  Save Webhook"
    SaveBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 200)
end)

CloseBtn.MouseButton1Click:Connect(function()
    ScreenGui:Destroy()
end)

--------------------------------------------------------------------
-- LOGGER
--------------------------------------------------------------------
local function sendCycleUpdate(cycleNum, reason)
    if WEBHOOK == "" then return end
    task.spawn(function()
        pcall(function()
            request({
                Url = WEBHOOK,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = HttpService:JSONEncode({
                    content = string.format(
                        "ðŸ” **Current loop %d** | %s\nðŸ’Ž **Gems:** %s",
                        cycleNum,
                        reason,
                        tostring(currentGems)
                    )
                })
            })
        end)
    end)
end

local function Log(msg)
    print("[AUTO] " .. msg)
end

--------------------------------------------------------------------
-- STATE
--------------------------------------------------------------------
local FuseDone = false
local ScreensDone = false
local ValvesDone = false
local cycleCount = 0

local function getChar()
    return lp.Character or lp.CharacterAdded:Wait()
end

local function getRoot()
    local char = getChar()
    return char and char:FindFirstChild("HumanoidRootPart")
end

--------------------------------------------------------------------
-- ANTI AFK
--------------------------------------------------------------------
local VirtualUser = game:GetService("VirtualUser")
lp.Idled:Connect(function()
    VirtualUser:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
    task.wait(0.1)
    VirtualUser:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
end)

--------------------------------------------------------------------
-- TASER LOOP
--------------------------------------------------------------------
task.spawn(function()
    while true do
        task.wait(0.1)
        local remotes = ReplicatedStorage:FindFirstChild("Remotes")
        local taser = remotes and remotes:FindFirstChild("UseTaser")
        if taser then
            pcall(function() taser:FireServer() end)
        end
    end
end)

--------------------------------------------------------------------
-- FUSE LOGIC
--------------------------------------------------------------------
local function findFuseComponents()
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj.Name == "Fuse" and obj:FindFirstChild("Sticks") and obj:FindFirstChild("Input") then
            return obj.Sticks, obj.Input
        end
    end
    return nil, nil
end

local function fusePromptsExist()
    local sticksFolder = findFuseComponents()
    if not sticksFolder then return false end
    local children = sticksFolder:GetChildren()
    local stick = children[1]
    return stick and stick:FindFirstChildOfClass("ProximityPrompt") ~= nil
end

-- FIX: safe position getter handles both BasePart and Model
local function getPosition(obj)
    if not obj then return nil end
    local ok, pos = pcall(function()
        if obj:IsA("Model") then
            return obj:GetPivot().Position
        else
            return obj.Position
        end
    end)
    return ok and pos or nil
end

local function interactWithTarget(target, holdTime)
    if not target then return false end
    local prompt = target:FindFirstChildOfClass("ProximityPrompt")
    if not prompt then
        local targetPos = getPosition(target)
        if targetPos then
            for _, v in ipairs(workspace:GetDescendants()) do
                if v:IsA("ProximityPrompt") then
                    local vPos = getPosition(v.Parent)
                    if vPos and (vPos - targetPos).Magnitude < 10 then
                        prompt = v
                        break
                    end
                end
            end
        end
    end
    if prompt then
        safeFireProximityPrompt(prompt)
        Log("Interacted with " .. target.Name)
        if holdTime then task.wait(holdTime) end
        return true
    end
    return false
end

local function runFuseSequence(cs)
    FuseDone = false
    Log("Waiting for fuse model...")

    local sticksFolder, inputFolder
    repeat
        if not cs.active then return end
        sticksFolder, inputFolder = findFuseComponents()
        task.wait(0.2)
    until sticksFolder and inputFolder

    Log("Fuse model detected")

    while cs.active do
        local stick = sticksFolder:GetChildren()[1]
        if stick and stick:FindFirstChildOfClass("ProximityPrompt") then
            Log("Fuse prompts detected â€” proceeding")
            break
        end
        task.wait(0.1)
    end
    if not cs.active then return end

    local root = getRoot()
    if not root then
        Log("ERROR: No HumanoidRootPart â€” aborting fuse")
        return
    end

    for _, slotName in ipairs({"One", "Two"}) do
        if not cs.active then return end

        -- FIX: re-fetch components each iteration and guard against nil
        sticksFolder, inputFolder = findFuseComponents()
        if not sticksFolder or not inputFolder then
            Log("Fuse components lost mid-sequence â€” aborting")
            return
        end

        local stick = sticksFolder:GetChildren()[1]
        while not stick and cs.active do
            sticksFolder, inputFolder = findFuseComponents()
            if sticksFolder then
                stick = sticksFolder:GetChildren()[1]
            end
            task.wait(0.1)
        end
        if not cs.active then return end
        if not stick then return end

        -- FIX: guard input nil before indexing
        local input = inputFolder and inputFolder:FindFirstChild(slotName)
        if not input then
            Log("Input slot '" .. slotName .. "' not found â€” skipping")
        else
            local stickPos = getPosition(stick)
            if stickPos then
                safeSetCFrame(root, CFrame.new(stickPos + Vector3.new(0, 2, 0)))
                task.wait(0.6)
            end
            interactWithTarget(stick)
            task.wait(0.5)

            local inputPos = getPosition(input)
            if inputPos then
                safeSetCFrame(root, CFrame.new(inputPos + Vector3.new(0, 2, 0)))
                task.wait(0.6)
            end
            interactWithTarget(input)
            task.wait(0.5)
        end
    end

    if not cs.active then return end

    local confirmed = false
    while not confirmed and cs.active do
        local sticks, inputs = findFuseComponents()
        if sticks and inputs then
            local children = sticks:GetChildren()
            if #children == 0 then
                local slotOne = inputs:FindFirstChild("One")
                local slotTwo = inputs:FindFirstChild("Two")
                local a = slotOne and slotOne:FindFirstChildOfClass("ProximityPrompt")
                local b = slotTwo and slotTwo:FindFirstChildOfClass("ProximityPrompt")
                if not a and not b then
                    confirmed = true
                end
            end
        else
            -- components gone â€” assume done
            confirmed = true
        end
        task.wait(0.1)
    end
    if not cs.active then return end

    FuseDone = true
    Log("Fuse completed")
end

--------------------------------------------------------------------
-- SCREEN SOLVER
--------------------------------------------------------------------
local function startScreenSolver(cs)
    ScreensDone = false
    Log("Starting screen solver")

    local screens = workspace:FindFirstChild("Screens", true)
    if not screens then
        ScreensDone = true
        Log("No screens found")
        return
    end

    local screenList = screens:GetChildren()
    local total = #screenList
    local completed = 0

    if total == 0 then
        ScreensDone = true
        return
    end

    for _, screen in ipairs(screenList) do
        task.spawn(function()
            while cs.active do
                -- FIX: pcall guards property access on potentially destroyed instance
                local ok, green = pcall(function()
                    return screen.Color and screen.Color.G == 1
                end)
                if ok and green then break end
                if not ok then break end  -- instance destroyed

                local click = pcall(function()
                    local cd = screen:FindFirstChild("PuzzleClickDetector", true)
                    if cd then
                        safeFireClickDetector(cd)
                        Log("Clicked screen " .. screen.Name)
                    end
                end)
                task.wait(0.5)
            end
            completed += 1
        end)
    end

    while completed < total and cs.active do
        task.wait(0.1)
    end

    if cs.active then
        ScreensDone = true
        Log("Screens solved")
    end
end

--------------------------------------------------------------------
-- VALVE HUNTER
--------------------------------------------------------------------
local function valvesDone(folder)
    for _, v in ipairs(folder:GetChildren()) do
        local p = v:FindFirstChildWhichIsA("ProximityPrompt", true)
        if p and p.Enabled then return false end
    end
    return true
end

local function runValveHunter(cs)
    ValvesDone = false
    Log("Starting valve hunter")

    local root = getRoot()
    if not root then
        Log("ERROR: No HumanoidRootPart â€” aborting valve hunter")
        ValvesDone = true
        return
    end

    while cs.active do
        local map
        for _, obj in ipairs(workspace:GetChildren()) do
            if obj:FindFirstChild("Puzzles") and obj.Puzzles:FindFirstChild("Valves") then
                map = obj
                break
            end
        end
        if not map then
            ValvesDone = true
            return
        end

        local valves = map.Puzzles.Valves
        if valvesDone(valves) then
            ValvesDone = true
            return
        end

        for _, valve in ipairs(valves:GetChildren()) do
            if not cs.active then return end
            -- FIX: pcall in case valve is destroyed mid-loop
            local ok, result = pcall(function()
                local prompt = valve:FindFirstChildWhichIsA("ProximityPrompt", true)
                if not prompt or not prompt.Enabled then return end

                local parent = prompt.Parent
                local pos = getPosition(parent)
                if not pos then return end

                local lookVec
                local ok2, lv = pcall(function()
                    if parent:IsA("Model") then
                        return parent:GetPivot().LookVector
                    else
                        return parent.CFrame.LookVector
                    end
                end)
                lookVec = ok2 and lv or Vector3.new(0, 0, 1)

                local start = tick()
                while prompt.Enabled and tick() - start < 6 and cs.active do
                    safeSetCFrame(root, CFrame.new(pos + lookVec * 2))
                    safeFireProximityPrompt(prompt)
                    task.wait(0.01)
                end
                Log("Valve completed: " .. valve.Name)
            end)
            if not ok then
                warn("[AUTO] Valve interaction error: " .. tostring(result))
            end
        end
    end
end

--------------------------------------------------------------------
-- WAIT FOR FUSE PROMPTS
--------------------------------------------------------------------
local function waitForFusePrompts(cs)
    Log("Waiting for fuse prompts")
    while cs.active do
        local sticks = findFuseComponents()
        local s = sticks and sticks:GetChildren()[1]
        if s and s:FindFirstChildOfClass("ProximityPrompt") then
            Log("Fuse prompts detected")
            return
        end
        task.wait(0.1)
    end
end

--------------------------------------------------------------------
-- AUTO REJOIN
--------------------------------------------------------------------
local function rejoin()
    Log("Rejoining server")

    -- Queue the script to re-execute in the NEW session after teleport lands
    if queue_on_teleport then
        queue_on_teleport([[
            loadstring(game:HttpGet(
                "https://raw.githubusercontent.com/orl95137-lgtm/Automation/refs/heads/main/Automation"
            ))()
        ]])
        Log("Queued script for post-teleport execution")
    else
        warn("[AUTO] queue_on_teleport not supported on this executor â€” script will not re-execute after rejoin")
    end

    pcall(function()
        TeleportService:Teleport(placeId, lp)
    end)
end

--------------------------------------------------------------------
-- TIMER FINDER
--------------------------------------------------------------------
local function findTimerValue()
    local gameInfo = workspace:FindFirstChild("GameInformation")
    if gameInfo then
        return gameInfo:FindFirstChild("Timer")
    end
    return nil
end

--------------------------------------------------------------------
-- INIT GEM TRACKER
--------------------------------------------------------------------
task.spawn(initGemTracker)

--------------------------------------------------------------------
-- MAIN LOOP
--------------------------------------------------------------------
task.spawn(function()
    while true do
        cycleCount += 1
        FuseDone, ScreensDone, ValvesDone = false, false, false

        local cs = { aborted = false, active = true }

        setCycle(cycleCount)
        setStatus("Running cycle " .. cycleCount, Color3.fromRGB(80, 180, 255))
        sendCycleUpdate(cycleCount, "Cycle started")
        Log("=== CYCLE " .. cycleCount .. " START ===")

        ----------------------------------------------------------------
        -- WATCHER: timer jump â†’ new round
        ----------------------------------------------------------------
        task.spawn(function()
            local timerObj = findTimerValue()
            if not timerObj then return end
            local lastValue = timerObj.Value

            while cs.active do
                task.wait(0.1)
                if not cs.active then return end

                -- FIX: pcall guards against destroyed timerObj
                local ok, newValue = pcall(function()
                    return timerObj.Value
                end)
                if not ok then
                    Log("Timer object destroyed â€” ending watcher")
                    return
                end

                if lastValue <= 120 and newValue > 120 then
                    Log("ABORT: Timer jumped above 120 â€” new round detected")
                    cs.aborted = true
                    cs.active = false
                    return
                end
                lastValue = newValue
            end
        end)

        ----------------------------------------------------------------
        -- STEP 1: Wait for fuse prompts (blocking)
        ----------------------------------------------------------------
        waitForFusePrompts(cs)

        ----------------------------------------------------------------
        -- STEP 2: Watch for fuse prompt reappearance (new round signal)
        ----------------------------------------------------------------
        if cs.active then
            task.spawn(function()
                while cs.active and fusePromptsExist() do
                    task.wait(0.1)
                end
                while cs.active do
                    task.wait(0.1)
                    if not cs.active then return end
                    if fusePromptsExist() then
                        Log("ABORT: Fuse prompts reappeared â€” new round detected")
                        cs.aborted = true
                        cs.active = false
                        return
                    end
                end
            end)
        end

        ----------------------------------------------------------------
        -- STEP 3: Run the puzzle sequence
        ----------------------------------------------------------------
        if cs.active then task.spawn(function() startScreenSolver(cs) end) end
        if cs.active then runFuseSequence(cs) end
        if cs.active then runValveHunter(cs) end

        if cs.active then
            while not (FuseDone and ScreensDone and ValvesDone) and cs.active do
                task.wait(0.1)
            end
        end

        cs.active = false

        if cs.aborted then
            setStatus("Aborted â€” restarting", Color3.fromRGB(220, 120, 60))
            sendCycleUpdate(cycleCount, "Cycle aborted â€” restarting")
            Log("Cycle aborted â€” restarting")
            task.wait(0.5)
            continue
        end

        setStatus("Cycle " .. cycleCount .. " complete âœ”", Color3.fromRGB(80, 220, 120))
        sendCycleUpdate(cycleCount, "Cycle complete â€” resetting character")
        Log("Cycle complete â€” resetting character")

        pcall(function()
            local hum = getChar():FindFirstChildOfClass("Humanoid")
            if hum then hum.Health = 0 end
        end)
        task.wait(1)

        if cycleCount >= 60 then
            setStatus("Rejoining...", Color3.fromRGB(220, 180, 60))
            sendCycleUpdate(cycleCount, "Reached 60 cycles â€” rejoining server")
            rejoin()
            break
        end
    end
end)
